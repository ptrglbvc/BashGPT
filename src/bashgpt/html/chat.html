{% extends "layout.html" %} {% block title %}{{ chat_info.description }}{%
endblock %} {% block content %}
<main class="chat-container">
    <div class="messages-container">
        {% for message in messages %}
        <div class="message-wrapper {{ message.role }}">
            <div class="message">
                <div class="message-content">
                    <div class="message-text">{{message["content"]|safe}}</div>
                    {% for image in images %} {% if image.message_idx ==
                    message.message_id %}
                    <div class="message-image">
                        <img
                            src="data:image/{{ image.extension }};base64,{{ image.content }}"
                            alt="{{ image.name }}"
                        />
                    </div>
                    {% endif %} {% endfor %} {% for file in files %} {% if
                    file.message_idx == message.message_id %}
                    <div class="message-file">
                        <i class="fa-solid fa-file"></i>
                        <span>{{ file.name }}</span>
                    </div>
                    {% endif %} {% endfor %}
                </div>
            </div>
        </div>
        {% endfor %}
    </div>
</main>
{% endblock %} {% block form_logic %}
<script>
    async function send_message(message) {
        return await fetch("/api/answer", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message: message }),
        });
    }

    function createMessageElement(role, message = "") {
        const messageWrapper = document.createElement("div");
        messageWrapper.className = `message-wrapper ${role}`;

        const messageDiv = document.createElement("div");
        messageDiv.className = "message";

        const messageContentDiv = document.createElement("div");
        messageContentDiv.className = "message-content";

        const messageText = document.createElement("div");
        messageText.className = "message-text";
        messageText.innerHTML = marked.parse(message);

        messageWrapper.appendChild(messageDiv);
        messageDiv.appendChild(messageContentDiv);
        messageContentDiv.appendChild(messageText);

        return messageWrapper;
    }

    function isUserAtBottom() {
        const tolerance = 15; // Pixels of tolerance to consider "at bottom"
        return (
            window.innerHeight + window.scrollY >=
            document.body.offsetHeight - tolerance
        );
    }

    const urlParams = new URLSearchParams(window.location.search);
    const params = {};
    for (const [key, value] of urlParams) {
        params[key] = value;
    }

    if (params["new_chat"] == "true") {
        wasAtBottom = isUserAtBottom();
        message = "";
        get_assistant_response(message, wasAtBottom);
    }

    let shoudlAutoScroll = false;

    // this handles the message sending part
    document
        .getElementById("message-form")
        .addEventListener("submit", async function (e) {
            e.preventDefault();
            const message = textarea.value.trim();
            if (!message) return;
            console.log(message);

            const wasAtBottom = isUserAtBottom();

            textarea.value = "";
            textarea.style.height = "auto";

            let user_message = createMessageElement("user", message);

            let messages_container = document.querySelector(
                ".messages-container"
            );

            messages_container.appendChild(user_message, message);

            get_assistant_response(message, wasAtBottom);

            // Scroll to bottom after adding user message if they were already at bottom
            if (wasAtBottom) {
                window.scrollTo({
                    top: document.body.scrollHeight,
                    behavior: "smooth",
                });
            }
        });

    async function get_assistant_response(message, wasAtBottom) {
        let assistant_message = createMessageElement("assistant");

        assistant_message_text =
            assistant_message.querySelector(".message-text");

        let messages_container = document.querySelector(".messages-container");
        messages_container.appendChild(assistant_message);

        res = await send_message(message);
        const reader = res.body.getReader();
        let output = "";
        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (
                    mutation.type === "childList" &&
                    mutation.addedNodes.length > 0
                ) {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1 && node.matches("pre")) {
                            attach_copy_button_to_code_block(node);
                        }
                    });
                }
            }
        });

        const observer_config = { childList: true, subtree: true };
        observer.o;
        // For tracking if we need to scroll during streaming
        const shouldAutoScroll = wasAtBottom;

        while (true) {
            const { done, value } = await reader.read();
            output += new TextDecoder()
                .decode(value)
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
            assistant_message_text.innerHTML = marked.parse(output);

            // Auto-scroll if the user was at the bottom
            if (shouldAutoScroll) {
                window.scrollTo({
                    top: document.body.scrollHeight,
                    behavior: "auto", // Using 'auto' instead of 'smooth' for streaming to avoid lag
                });
            }

            if (done) {
                observer.disconnect();

                // without this the button may very likely disappear
                assistant_message_text
                    .querySelectorAll("pre")
                    .forEach((pre) => {
                        if (!pre.querySelector(".code-copy-button")) {
                            attach_copy_button_to_code_block(pre);
                        }
                    });
                return;
            }
        }
        bserve(assistant_message_text, observer_config);
    }
</script>
{% endblock %}
