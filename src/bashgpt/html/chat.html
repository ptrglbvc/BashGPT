{% extends "layout.html" %} {% block title %}{{ chat_info.description }}{%
endblock %} {% block content %}
<main class="chat-container" data-theme="{{ defaults.web.theme | default('chatgpt') }}">
    <!-- Pass backend model capability to JS -->
    <div id="anthropic-cache-enabled" data-enabled="{{ chat_info.anthropic_cache_control | lower }}" style="display:none;"></div>
    
    <div class="messages-container">
        {% for message in messages %}
        <div class="message-wrapper {{ message.role }}" data-cache="{{ message.cache_control | lower }}">
            <div class="message">
                <div class="message-content">
                    {% if message.role == "assistant" %}
                    <div class="message-role-icon">
                        <i class="fa-solid fa-robot"></i>
                        <span>Assistant</span>
                    </div>
                    {% elif message.role == "user" %}
                    <div class="message-role-icon">
                        <i class="fa-solid fa-user"></i>
                        <span>You</span>
                    </div>
                    {% endif %}
                    <div
                        class="message-text preserve-whitespace"
                        data-raw-text="{{message['content']}}"
                    >
                        {{message["content"]|safe}}
                    </div>

                    {% set imgs = images | selectattr('message_idx', 'equalto',
                    message.message_id) | list %} {% if imgs %}
                    <div
                        class="message-image-wrapper"
                        style="padding-bottom: 10px"
                    >
                        {% for image in imgs %}
                        <div
                            class="message-image"
                            data-image-src="data:image/{{ image.extension }};base64,{{ image.content }}"
                            data-image-name="{{ image.name }}"
                        >
                            <img
                                src="data:image/{{ image.extension }};base64,{{ image.content }}"
                                alt="{{ image.name }}"
                            />
                        </div>
                        {% endfor %}
                    </div>
                    {% endif %} {% for file in files %} {% if file.message_idx
                    == message.message_id %}
                    <div class="message-file">
                        <i class="fa-solid fa-file"></i>
                        <span>{{ file.name }}</span>
                    </div>
                    {% endif %} {% endfor %}

                    <div class="message-actions">
                        {% if chat_info.anthropic_cache_control %}
                        <div class="cache-control-wrapper" title="Toggle Anthropic Cache (Ephemeral)">
                            <input type="checkbox" class="cache-checkbox" id="cache-{{message.message_id}}" {% if message.cache_control %}checked{% endif %}>
                            <label for="cache-{{message.message_id}}" class="cache-label"><i class="fa-solid fa-bolt"></i> Cache</label>
                        </div>
                        {% endif %}
                        
                        <button
                            class="message-action-btn copy-message"
                            title="Copy message"
                        >
                            <i class="fa-solid fa-copy"></i>
                        </button>
                        {% if message.role == "assistant" %}
                        <button
                            class="message-action-btn regenerate-message"
                            title="Regenerate"
                        >
                            <i class="fa-solid fa-rotate"></i>
                        </button>
                        <button
                            class="message-action-btn continue-message"
                            title="Continue"
                        >
                            <i class="fa-solid fa-arrow-right"></i>
                        </button>
                        {% endif %}
                        <button
                            class="message-action-btn branch-message"
                            title="Branch chat"
                        >
                            <i class="fa-solid fa-code-branch"></i>
                        </button>
                        <button
                            class="message-action-btn edit-message"
                            title="Edit message"
                        >
                            <i class="fa-solid fa-pen"></i>
                        </button>
                        <button
                            class="message-action-btn delete-message"
                            title="Delete message"
                        >
                            <i class="fa-solid fa-trash"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        {% endfor %}
    </div>

    <div class="image-modal">
        <div class="image-modal-close">
            <i class="fa-solid fa-times"></i>
        </div>
        <img class="image-modal-content" src="" alt="Expanded Image" />
    </div>
</main>
{% endblock %} {% block form_logic %}
<script>
    // --- GLOBAL STATE ---
    let isStreaming = false;

    // --- API WRAPPERS ---
    async function send_message_api(message) {
        return await fetch("/api/answer", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message: message }),
        });
    }

    async function regenerate_message_api(index) {
        return await fetch("/api/regenerate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ index: index }),
        });
    }

    async function continue_message_api(index) {
        return await fetch("/api/continue", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ index: index }),
        });
    }

    // --- EVENT DELEGATION ---
    document.querySelector(".messages-container").addEventListener("click", (e) => {
        // Handle Image Clicks
        const imgWrapper = e.target.closest(".message-image");
        if (imgWrapper) {
            openImageModal(imgWrapper);
            return;
        }

        // Handle Button Clicks
        const btn = e.target.closest(".message-action-btn");
        const cacheLabel = e.target.closest(".cache-label");
        const cacheInput = e.target.closest(".cache-checkbox");
        
        const messageWrapper = e.target.closest(".message-wrapper");
        if (!messageWrapper) return;

        // Handle Cache Toggle (checkbox or label)
        if (cacheInput) {
            toggleCache(messageWrapper);
            return;
        }
        
        if (!btn) return; // Not a button we care about

        // Actions
        if (btn.classList.contains("copy-message")) {
            copyMessage(messageWrapper.querySelector(".message-text"), btn);
        } else if (btn.classList.contains("regenerate-message")) {
            if (!isStreaming) regenerateMessage(messageWrapper);
        } else if (btn.classList.contains("continue-message")) {
            if (!isStreaming) continueMessage(messageWrapper);
        } else if (btn.classList.contains("branch-message")) {
            branchMessage(messageWrapper);
        } else if (btn.classList.contains("edit-message")) {
            editMessage(messageWrapper);
        } else if (btn.classList.contains("delete-message")) {
            deleteMessage(messageWrapper);
        }
    });

    // --- MESSAGE CREATION ---
    function createMessageElement(role, message = "") {
        const messageWrapper = document.createElement("div");
        messageWrapper.className = `message-wrapper ${role}`;

        const messageDiv = document.createElement("div");
        messageDiv.className = "message";

        const messageContentDiv = document.createElement("div");
        messageContentDiv.className = "message-content";

        // Add role icon
        const roleIconDiv = document.createElement("div");
        roleIconDiv.className = "message-role-icon";

        if (role === "assistant") {
            roleIconDiv.innerHTML = '<i class="fa-solid fa-robot"></i><span>Assistant</span>';
        } else if (role === "user") {
            roleIconDiv.innerHTML = '<i class="fa-solid fa-user"></i><span>You</span>';
        }

        messageContentDiv.appendChild(roleIconDiv);

        const messageText = document.createElement("div");
        messageText.className = "message-text preserve-whitespace";
        messageText.setAttribute("data-raw-text", message);
        messageText.innerHTML = marked.parse(message);

        messageDiv.appendChild(messageContentDiv);
        messageContentDiv.appendChild(messageText);
        messageWrapper.appendChild(messageDiv);

        // Process images within markdown (data:image)
        const imgRegex = /!\[.*?\]\((data:image\/[\w+]+;base64,[^\s)]+)\)/g;
        let match;
        while ((match = imgRegex.exec(message)) !== null) {
            const imgSrc = match[1];
            const imageWrapper = document.createElement("div");
            imageWrapper.className = "message-image message-image-wrapper";
            imageWrapper.setAttribute("data-image-src", imgSrc);
            imageWrapper.setAttribute("data-image-name", "Image");
            
            const img = document.createElement("img");
            img.src = imgSrc;
            img.alt = "Image";
            imageWrapper.appendChild(img);
            
            messageContentDiv.appendChild(imageWrapper);
        }

        // Create message actions
        const messageActions = document.createElement("div");
        messageActions.className = "message-actions";

        // Cache control
        const cacheEnabledDiv = document.getElementById("anthropic-cache-enabled");
        if (cacheEnabledDiv && cacheEnabledDiv.getAttribute("data-enabled") === "true") {
            const cacheWrapper = document.createElement("div");
            cacheWrapper.className = "cache-control-wrapper";
            cacheWrapper.title = "Toggle Anthropic Cache (Ephemeral)";
            
            const tempId = "cache-new-" + Date.now() + Math.random().toString(36).substring(7);
            
            cacheWrapper.innerHTML = `
                <input type="checkbox" class="cache-checkbox" id="${tempId}">
                <label for="${tempId}" class="cache-label"><i class="fa-solid fa-bolt"></i> Cache</label>
            `;
            messageActions.appendChild(cacheWrapper);
        }

        // Action buttons HTML string for performance/cleanliness
        let buttonsHtml = `
            <button class="message-action-btn copy-message" title="Copy message"><i class="fa-solid fa-copy"></i></button>
        `;
        
        if (role === "assistant") {
            buttonsHtml += `
                <button class="message-action-btn regenerate-message" title="Regenerate"><i class="fa-solid fa-rotate"></i></button>
                <button class="message-action-btn continue-message" title="Continue"><i class="fa-solid fa-arrow-right"></i></button>
            `;
        }
        
        buttonsHtml += `
            <button class="message-action-btn branch-message" title="Branch chat"><i class="fa-solid fa-code-branch"></i></button>
            <button class="message-action-btn edit-message" title="Edit message"><i class="fa-solid fa-pen"></i></button>
            <button class="message-action-btn delete-message" title="Delete message"><i class="fa-solid fa-trash"></i></button>
        `;

        // We can safely use innerHTML here for buttons as they contain no user content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = buttonsHtml;
        while (tempDiv.firstChild) {
            messageActions.appendChild(tempDiv.firstChild);
        }

        messageContentDiv.appendChild(messageActions);

        return messageWrapper;
    }

    // --- ACTIONS IMPLEMENTATION ---

    async function toggleCache(messageWrapper) {
        const allMessageWrappers = Array.from(document.querySelectorAll(".message-wrapper"));
        const messageIndex = allMessageWrappers.indexOf(messageWrapper);
        
        try {
            const res = await fetch("/api/toggle_cache", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ index: messageIndex })
            });
            
            const data = await res.json();
            if (data.success) {
                messageWrapper.setAttribute("data-cache", data.new_value);
                const cb = messageWrapper.querySelector(".cache-checkbox");
                if (cb) cb.checked = data.new_value;
                if (data.new_value) {
                    showNotification("Message cached (Ephemeral)", 1500);
                }
            } else {
                showNotification("Failed to toggle cache", 3000);
                // Revert UI
                const cb = messageWrapper.querySelector(".cache-checkbox");
                if (cb) cb.checked = !cb.checked;
            }
        } catch (e) {
            console.error(e);
            showNotification("Error toggling cache", 3000);
        }
    }

    function openImageModal(element) {
        const imageSrc = element.getAttribute("data-image-src");
        const imageName = element.getAttribute("data-image-name");
        const imageModal = document.querySelector(".image-modal");
        const modalImage = document.querySelector(".image-modal-content");

        const updateModal = () => {
            modalImage.src = imageSrc;
            modalImage.alt = imageName;
            imageModal.classList.add("active");
        };

        if (document.startViewTransition) {
            document.startViewTransition(updateModal);
        } else {
            updateModal();
        }
    }

    function copyMessage(messageTextElement, btnElement) {
        const rawText = messageTextElement.getAttribute("data-raw-text");
        navigator.clipboard.writeText(rawText)
            .then(() => {
                const originalIcon = btnElement.innerHTML;
                btnElement.innerHTML = '<i class="fa-solid fa-check"></i>';
                setTimeout(() => {
                    btnElement.innerHTML = originalIcon;
                }, 2000);
            })
            .catch((err) => console.error("Failed to copy:", err));
    }

    // --- STREAMING LOGIC ---

    async function regenerateMessage(messageWrapper) {
        if (isStreaming) return;
        isStreaming = true;

        const allMessageWrappers = Array.from(document.querySelectorAll(".message-wrapper"));
        const messageIndex = allMessageWrappers.indexOf(messageWrapper);
        const text_contents = messageWrapper.querySelector(".message-text");
        
        const regenerateBtn = messageWrapper.querySelector(".regenerate-message");
        if (regenerateBtn) {
            regenerateBtn.classList.add("rotate-animation");
            regenerateBtn.addEventListener("animationend", () => regenerateBtn.classList.remove("rotate-animation"), { once: true });
        }

        // ERP Setup
        const isErp = document.body.classList.contains("theme-erp");
        let caretEl = isErp ? document.createElement("span") : null;
        if (caretEl) {
            caretEl.className = "erp-caret";
            messageWrapper.classList.add("erp-typing");
        }

        const previousRaw = text_contents.getAttribute("data-raw-text") || "";
        const previousHTML = text_contents.innerHTML;

        // Clear content for regeneration
        text_contents.innerHTML = "";
        text_contents.setAttribute("data-raw-text", "");
        if (caretEl) text_contents.appendChild(caretEl);

        try {
            const res = await regenerate_message_api(messageIndex);
            await processStream(res, text_contents, messageWrapper, caretEl, previousRaw, previousHTML);
        } catch (e) {
            console.error(e);
            handleStreamError(text_contents, messageWrapper, e.toString(), caretEl, previousRaw, previousHTML);
        } finally {
            isStreaming = false;
        }
    }

    async function continueMessage(messageWrapper) {
        if (isStreaming) return;
        isStreaming = true;

        const allMessageWrappers = Array.from(document.querySelectorAll(".message-wrapper"));
        const messageIndex = allMessageWrappers.indexOf(messageWrapper);
        const text_contents = messageWrapper.querySelector(".message-text");

        const isErp = document.body.classList.contains("theme-erp");
        let caretEl = isErp ? document.createElement("span") : null;
        if (caretEl) {
            caretEl.className = "erp-caret";
            messageWrapper.classList.add("erp-typing");
            text_contents.appendChild(caretEl);
        }
        
        // For continue, we keep existing text
        const previousRaw = text_contents.getAttribute("data-raw-text") || "";
        const previousHTML = text_contents.innerHTML;

        try {
            const res = await continue_message_api(messageIndex);
            await processStream(res, text_contents, messageWrapper, caretEl, previousRaw, previousHTML, true);
        } catch (e) {
            console.error(e);
            handleStreamError(text_contents, messageWrapper, e.toString(), caretEl, previousRaw, previousHTML);
        } finally {
            isStreaming = false;
        }
    }

    async function get_assistant_response(message, wasAtBottom) {
        if (isStreaming) return;
        isStreaming = true;

        let assistant_message = createMessageElement("assistant");
        document.querySelector(".messages-container").appendChild(assistant_message);
        const text_contents = assistant_message.querySelector(".message-text");

        const isErp = document.body.classList.contains("theme-erp");
        let caretEl = isErp ? document.createElement("span") : null;
        if (caretEl) {
            caretEl.className = "erp-caret";
            assistant_message.classList.add("erp-typing");
            text_contents.appendChild(caretEl);
        }

        try {
            const res = await send_message_api(message);
            await processStream(res, text_contents, assistant_message, caretEl, "", "", false, wasAtBottom);
        } catch (e) {
            console.error(e);
            handleStreamError(text_contents, assistant_message, e.toString(), caretEl, "", "", true);
        } finally {
            isStreaming = false;
        }
    }

    async function processStream(res, textElement, messageWrapper, caretEl, prevRaw, prevHTML, isContinue = false, wasAtBottom = false) {
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let output = isContinue ? (textElement.getAttribute("data-raw-text") || "") : "";
        
        // Setup observer for code blocks
        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1 && node.matches("pre") && !node.querySelector(".code-copy-button")) {
                            attach_copy_button_to_code_block(node);
                        }
                    });
                }
            }
        });
        observer.observe(textElement, { childList: true, subtree: true });

        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value);
                if (chunk.startsWith("__ERROR__:")) {
                    throw new Error(chunk.replace("__ERROR__:", ""));
                }

                output += chunk;
                textElement.setAttribute("data-raw-text", output);
                textElement.innerHTML = marked.parse(output.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
                
                // Re-append caret
                if (caretEl) textElement.appendChild(caretEl);

                // Highlight code
                if (typeof Prism !== "undefined") {
                     // We use highlightAllUnder carefully to avoid resetting DOM too much
                     // But Prism usually requires reparsing.
                     // For performance, maybe only highlight on done? 
                     // But user requested fix, not perf optimization. Let's keep it lively.
                     Prism.highlightAllUnder(textElement);
                }

                if (wasAtBottom || isUserAtBottom()) {
                    window.scrollTo({ top: document.body.scrollHeight, behavior: "auto" });
                }
            }
        } catch (e) {
            observer.disconnect();
            throw e; // Rethrow to handle in caller
        }

        // Cleanup success
        observer.disconnect();
        textElement.querySelectorAll("pre").forEach(pre => {
             if (!pre.querySelector(".code-copy-button")) attach_copy_button_to_code_block(pre);
        });
        
        if (caretEl && caretEl.parentNode) caretEl.parentNode.removeChild(caretEl);
        if (messageWrapper) messageWrapper.classList.remove("erp-typing");
    }

    function handleStreamError(textElement, messageWrapper, errorMsg, caretEl, prevRaw, prevHTML, removeOnFail = false) {
        showNotification(`Error: ${errorMsg}`, 5000);
        
        if (removeOnFail) {
            if (messageWrapper && messageWrapper.parentNode) messageWrapper.remove();
        } else {
            // Restore previous state
            textElement.setAttribute("data-raw-text", prevRaw);
            textElement.innerHTML = prevHTML;
            if (typeof Prism !== "undefined") Prism.highlightAllUnder(textElement);
            // Re-attach copy buttons
             textElement.querySelectorAll("pre").forEach(pre => {
                 if (!pre.querySelector(".code-copy-button")) attach_copy_button_to_code_block(pre);
            });
        }

        if (caretEl && caretEl.parentNode) caretEl.parentNode.removeChild(caretEl);
        if (messageWrapper) messageWrapper.classList.remove("erp-typing");
    }

    // --- OTHER ACTIONS ---

    function editMessage(messageWrapper) {
        const messageContent = messageWrapper.querySelector(".message-content");
        const messageText = messageWrapper.querySelector(".message-text");
        const rawText = messageText.getAttribute("data-raw-text");
        const originalContentHTML = messageContent.innerHTML; // Snapshot

        // Create edit interface
        const editContainer = document.createElement("div");
        editContainer.className = "message-edit-container";
        
        const textarea = document.createElement("textarea");
        textarea.className = "message-edit-textarea";
        textarea.value = rawText;
        
        const buttonsContainer = document.createElement("div");
        buttonsContainer.className = "message-edit-buttons";
        
        const saveBtn = document.createElement("button");
        saveBtn.className = "message-edit-btn save-edit";
        saveBtn.innerText = "Save";
        
        const cancelBtn = document.createElement("button");
        cancelBtn.className = "message-edit-btn cancel-edit";
        cancelBtn.innerText = "Cancel";
        
        buttonsContainer.append(saveBtn, cancelBtn);
        editContainer.append(textarea, buttonsContainer);
        
        // Replace content
        messageContent.innerHTML = "";
        messageContent.appendChild(editContainer);
        
        // Auto-height
        textarea.style.height = "auto";
        textarea.style.height = textarea.scrollHeight + "px";

        // Listeners (local because ephemeral)
        cancelBtn.onclick = () => {
            messageContent.innerHTML = originalContentHTML;
        };

        saveBtn.onclick = async () => {
            const newContent = textarea.value.trim();
            if (!newContent) return;

            const allMessageWrappers = Array.from(document.querySelectorAll(".message-wrapper"));
            const messageIndex = allMessageWrappers.indexOf(messageWrapper);

            try {
                const res = await fetch("/api/update_message", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ index: messageIndex, content: newContent })
                });

                if (res.ok) {
                    // Restore UI with new content
                    messageContent.innerHTML = originalContentHTML;
                    const textEl = messageContent.querySelector(".message-text");
                    textEl.setAttribute("data-raw-text", newContent);
                    textEl.innerHTML = marked.parse(newContent.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
                    
                    if (typeof Prism !== "undefined") Prism.highlightAllUnder(textEl);
                    textEl.querySelectorAll("pre").forEach(pre => {
                         if (!pre.querySelector(".code-copy-button")) attach_copy_button_to_code_block(pre);
                    });
                } else {
                    showNotification("Failed to save edit", 3000);
                }
            } catch (e) {
                console.error(e);
                showNotification("Error saving edit", 3000);
            }
        };
    }

    async function deleteMessage(messageWrapper) {
        if (!confirm("Are you sure you want to delete this message?")) return;

        const allMessageWrappers = Array.from(document.querySelectorAll(".message-wrapper"));
        const messageIndex = allMessageWrappers.indexOf(messageWrapper);

        try {
            const res = await fetch("/api/delete_message", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ index: messageIndex })
            });

            if (res.ok) {
                messageWrapper.remove();
            } else {
                showNotification("Failed to delete message", 3000);
            }
        } catch (e) {
            console.error(e);
            showNotification("Error deleting message", 3000);
        }
    }

    async function branchMessage(messageWrapper) {
        const allMessageWrappers = Array.from(document.querySelectorAll(".message-wrapper"));
        const messageIndex = allMessageWrappers.indexOf(messageWrapper);
        const chatId = window.location.pathname.split('/').pop();

        try {
            const res = await fetch("/api/branch", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ chat_id: parseInt(chatId), index: messageIndex })
            });
            const data = await res.json();
            if (data.success) {
                window.location.href = "/chat/" + data.chat_id;
            } else {
                showNotification("Failed to branch chat", 3000);
            }
        } catch (e) {
            console.error(e);
            showNotification("Error branching chat", 3000);
        }
    }

    function isUserAtBottom() {
        const tolerance = 20;
        return (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - tolerance);
    }

    // --- INITIALIZATION ---
    document.addEventListener("DOMContentLoaded", function () {
        const textarea = document.getElementById("message-input");
        const form = document.getElementById("message-form");

        // ERP clear typing effect on input
        if (document.body.classList.contains('theme-erp') && textarea) {
            textarea.addEventListener('input', () => {
                document.querySelectorAll('.message-wrapper.assistant.erp-typing').forEach(w => {
                    w.classList.remove('erp-typing');
                    const caret = w.querySelector('.erp-caret');
                    if (caret) caret.remove();
                });
            });
        }

        // Global code block copy button init (for pre-rendered messages)
        document.querySelectorAll("pre").forEach(pre => {
             if (!pre.querySelector(".code-copy-button")) attach_copy_button_to_code_block(pre);
        });

        // Image modal logic
        const imageModal = document.querySelector(".image-modal");
        const closeModal = () => {
            const removeClass = () => imageModal.classList.remove("active");
            if (document.startViewTransition) document.startViewTransition(removeClass);
            else removeClass();
        };

        document.querySelector(".image-modal-close").addEventListener("click", closeModal);
        imageModal.addEventListener("click", (e) => { if (e.target === imageModal) closeModal(); });
        document.addEventListener("keydown", (e) => { if (e.key === "Escape" && imageModal.classList.contains("active")) closeModal(); });

        // Handle URL params
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get("new_chat") === "true") {
             // Remove param from URL
             const url = new URL(window.location);
             url.searchParams.delete("new_chat");
             window.history.replaceState({}, document.title, url);
             
             // Trigger assistant welcome (empty string logic from old code)
             // We pass empty string, but check backend logic. Usually this triggers an empty prompt to AI? 
             // Or assumes the previous page created the chat with a message.
             // If this was meant to fetch the FIRST response to a user message sent via home:
             // The home page /api/create-new-chat usually saves the user message. 
             // We need to trigger response for that.
             get_assistant_response("", true);
        }

        // Form Submit
        form.addEventListener("submit", async function (e) {
            e.preventDefault();
            const message = textarea.value.trim();
            if (!message) return;

            if (message.startsWith("/")) {
                await handleCommand(message);
                textarea.value = "";
                textarea.style.height = "auto";
                return;
            }
            
            if (isStreaming) return; // double check

            const wasAtBottom = isUserAtBottom();
            
            textarea.value = "";
            textarea.style.height = "auto";

            // Add user message to UI
            const userMsgEl = createMessageElement("user", message);
            document.querySelector(".messages-container").appendChild(userMsgEl);

            if (wasAtBottom) window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" });

            await get_assistant_response(message, wasAtBottom);
        });
    });

    let shouldAutoScroll = false;
</script>
{% endblock %}
